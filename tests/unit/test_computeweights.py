# Generated by Qodo Gen

import pytest
from vvm.main import compute_weights  # Import the compute_weights function

class TestComputeWeights:

    # Compute correct weights x1, x2, x3 for valid input parameters
    # Compute correct weights x1, x2, x3 for valid input parameters
    def test_compute_weights_valid_inputs(self):
        # Arrange
        S, T, r = 100.0, 1.0, 0.05
        K, K1, K2, K3 = 100.0, 90.0, 100.0, 110.0
        sigma = sigma1 = sigma2 = sigma3 = 0.2
    
        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, 
                                   sigma, sigma1, sigma2, sigma3,
                                   S, T, r)
    
        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3) > 0  # Weights should not all be zero
   
    # Ensure the function raises ZeroDivisionError when strike price K is zero.
    def test_compute_weights_zero_strike(self):
        # Arrange
        S = 100.0
        K = 0.0  # Zero strike
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Act & Assert
        with pytest.raises(ZeroDivisionError):
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

    # Return tuple of three float values representing the weights
    def test_compute_weights_valid_inputs(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Mock bs_vega to return non-zero values to avoid division by zero
        mocker.patch('src.vvm.main.bs_vega', side_effect=[0.5, 0.45, 0.5, 0.55])

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Handle typical market parameters (S=100, K=100, T=1, r=0.05)
    def test_compute_weights_typical_market_parameters(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0
        K1 = 95.0
        K2 = 105.0
        K3 = 110.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.18
        sigma3 = 0.15
    # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float)
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

        # Mock bs_vega to return non-zero values to avoid division by zero
        mocker.patch('src.vvm.main.bs_vega', side_effect=lambda S, K, T, r, sigma: 0.5)

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float)
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float)
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Calculate weights for different strike price combinations
    def test_compute_weights_with_mocked_vega(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Mock the bs_vega function to return fixed values
        mocker.patch('src.vvm.main.bs_vega', side_effect=[0.2, 0.18, 0.19, 0.21])

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Process small and large time to expiry values correctly
    def test_compute_weights_small_and_large_expiry(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Test with small time to expiry
        T_small = 0.01
        x1_small, x2_small, x3_small = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T_small, r)
        assert isinstance(x1_small, float)
        assert isinstance(x2_small, float)
        assert isinstance(x3_small, float)
        assert abs(x1_small + x2_small + x3_small - 1.0) < 1e-10

        # Test with large time to expiry
        T_large = 10.0
        x1_large, x2_large, x3_large = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T_large, r)
        assert isinstance(x1_large, float)
        assert isinstance(x2_large, float)
        assert isinstance(x3_large, float)
        assert abs(x1_large + x2_large + x3_large - 1.0) < 1e-10

    # Verify that compute_weights raises a ValueError for zero spot prices and accepts negative spot prices, as per the recommended fix.
    def test_zero_or_negative_spot_price_handling(self):
        # Arrange
        K = 100.0
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Act & Assert for zero spot price
        try:
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, 0.0, T, r)
            zero_spot_price_passed = True
        except ValueError:
            zero_spot_price_passed = False

        # Act & Assert for negative spot price
        try:
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, -100.0, T, r)
            negative_spot_price_passed = True
        except ValueError:
            negative_spot_price_passed = False

        assert not zero_spot_price_passed, "Zero spot price should raise ValueError"
        assert negative_spot_price_passed, "Negative spot price should be accepted"

    # Raise ValueError when any vega computation returns zero
    def test_vega_computation_returns_zero(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Mock bs_vega to return zero for one of the strikes
        mocker.patch('src.vvm.main.bs_vega', side_effect=[0, 1, 1, 1])

        # Act & Assert
        with pytest.raises(ValueError, match="One of the computed vegas is zero; check inputs."):
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

    # Handle cases where K1=K2=K3 (identical strikes)
    def test_identical_strikes(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0
        K1 = 100.0
        K2 = 100.0
        K3 = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.2
        sigma2 = 0.2
        sigma3 = 0.2

        # Mock bs_vega to avoid division by zero and control the output
        mocker.patch('src.vvm.main.bs_vega', return_value=1.0)

        # Act & Assert
        with pytest.raises(ValueError, match="One of the computed vegas is zero; check inputs."):
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)


# Generated by Qodo Gen

import pytest

class TestComputeWeights:

    # Compute correct weights x1, x2, x3 for valid input parameters
    def test_compute_weights_valid_params(self):
        # Arrange
        S, T, r = 100.0, 1.0, 0.05
        K = 100.0
        K1, K2, K3 = 95.0, 100.0, 105.0
        sigma = sigma1 = sigma2 = sigma3 = 0.2
    
        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, 
                                   sigma, sigma1, sigma2, sigma3,
                                   S, T, r)
    
        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum should be close to 1

    # Ensure that compute_weights raises ZeroDivisionError when K is zero.
    def test_compute_weights_zero_strike(self):
        # Arrange
        S, T, r = 100.0, 1.0, 0.05
        K = 0.0  # Zero strike
        K1, K2, K3 = 95.0, 100.0, 105.0
        sigma = sigma1 = sigma2 = sigma3 = 0.2

        # Act & Assert
        with pytest.raises(ZeroDivisionError):
            compute_weights(K, K1, K2, K3,
                          sigma, sigma1, sigma2, sigma3, 
                          S, T, r)

    # Return tuple of three float values representing the weights
    def test_compute_weights_typical_parameters(self):
        S = 100
        K = 100
        K1 = 95
        K2 = 105
        K3 = 110
        sigma = 0.2
        sigma1 = 0.18
        sigma2 = 0.22
        sigma3 = 0.25
        T = 1
        r = 0.05
    
        expected_x1, expected_x2, expected_x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)
    
        assert isinstance(expected_x1, float)
        assert isinstance(expected_x2, float)
        assert isinstance(expected_x3, float)

    # Validate the computation of weights x1, x2, and x3 for typical market parameters, allowing x3 to be negative.
    def test_typical_market_parameters_with_negative_x3(self):
        S = 100
        K = 100
        K1 = 95
        K2 = 105
        K3 = 110
        sigma = 0.2
        sigma1 = 0.18
        sigma2 = 0.22
        sigma3 = 0.25
        T = 1
        r = 0.05

        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        assert isinstance(x1, float)
        assert isinstance(x2, float)
        assert isinstance(x3, float)
        assert x1 > 0
        assert x2 > 0
        assert x3 < 0

    # Process different strike price combinations where K1 < K2 < K3
    def test_compute_weights_with_ordered_strikes(self):
        S = 100
        T = 1
        r = 0.05
        K = 100
        K1 = 90
        K2 = 100
        K3 = 110
        sigma = 0.2
        sigma1 = 0.18
        sigma2 = 0.2
        sigma3 = 0.22
    
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)
    
        assert x1 >= 0, "Weight x1 should be non-negative"
        assert x2 >= 0, "Weight x2 should be non-negative"
        assert x3 >= 0, "Weight x3 should be non-negative"

    # Test with non-equal strikes to verify the correct computation of weights, allowing for negative weights if applicable.
    def test_non_equal_strikes_with_negative_weight(self):
        S = 100
        T = 1
        r = 0.05
        K = 95
        K1 = 90
        K2 = 100
        K3 = 110
        sigma = 0.2
        sigma1 = 0.18
        sigma2 = 0.2
        sigma3 = 0.22

        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        assert x1 > 0, "Weight x1 should be positive"
        assert x2 > 0, "Weight x2 should be positive"
        assert x3 < 0, "Weight x3 should be negative"