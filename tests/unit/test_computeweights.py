# Generated by Qodo Gen

import pytest
from vvm.main import compute_weights  # Import the compute_weights function

class TestComputeWeights:

    # Compute correct weights x1, x2, x3 for valid input parameters
    def test_compute_weights_valid_inputs(self):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Ensure the function raises ZeroDivisionError when strike price K is zero.
    def test_compute_weights_zero_strike(self):
        # Arrange
        S = 100.0
        K = 0.0  # Zero strike
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Act & Assert
        with pytest.raises(ZeroDivisionError):
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

    # Return tuple of three float values representing the weights
    def test_compute_weights_valid_inputs(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Mock bs_vega to return non-zero values to avoid division by zero
        mocker.patch('src.vvm.main.bs_vega', side_effect=[0.5, 0.45, 0.5, 0.55])

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Handle typical market parameters (S=100, K=100, T=1, r=0.05)
    def test_compute_weights_typical_market_parameters(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0
        K1 = 95.0
        K2 = 105.0
        K3 = 110.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.18
        sigma3 = 0.15

        # Mock bs_vega to return non-zero values to avoid division by zero
        mocker.patch('src.vvm.main.bs_vega', side_effect=lambda S, K, T, r, sigma: 0.5)

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float)
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Calculate weights for different strike price combinations
    def test_compute_weights_with_mocked_vega(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Mock the bs_vega function to return fixed values
        mocker.patch('src.vvm.main.bs_vega', side_effect=[0.2, 0.18, 0.19, 0.21])

        # Act
        x1, x2, x3 = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

        # Assert
        assert isinstance(x1, float)
        assert isinstance(x2, float) 
        assert isinstance(x3, float)
        assert abs(x1 + x2 + x3 - 1.0) < 1e-10  # Sum of weights should be close to 1

    # Process small and large time to expiry values correctly
    def test_compute_weights_small_and_large_expiry(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Test with small time to expiry
        T_small = 0.01
        x1_small, x2_small, x3_small = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T_small, r)
        assert isinstance(x1_small, float)
        assert isinstance(x2_small, float)
        assert isinstance(x3_small, float)
        assert abs(x1_small + x2_small + x3_small - 1.0) < 1e-10

        # Test with large time to expiry
        T_large = 10.0
        x1_large, x2_large, x3_large = compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T_large, r)
        assert isinstance(x1_large, float)
        assert isinstance(x2_large, float)
        assert isinstance(x3_large, float)
        assert abs(x1_large + x2_large + x3_large - 1.0) < 1e-10

    # Verify that compute_weights raises a ValueError for zero spot prices and accepts negative spot prices, as per the recommended fix.
    def test_zero_or_negative_spot_price_handling(self):
        # Arrange
        K = 100.0
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Act & Assert for zero spot price
        try:
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, 0.0, T, r)
            zero_spot_price_passed = True
        except ValueError:
            zero_spot_price_passed = False

        # Act & Assert for negative spot price
        try:
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, -100.0, T, r)
            negative_spot_price_passed = True
        except ValueError:
            negative_spot_price_passed = False

        assert not zero_spot_price_passed, "Zero spot price should raise ValueError"
        assert negative_spot_price_passed, "Negative spot price should be accepted"

    # Raise ValueError when any vega computation returns zero
    def test_vega_computation_returns_zero(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0 
        K1 = 95.0
        K2 = 100.0
        K3 = 105.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.22
        sigma2 = 0.2
        sigma3 = 0.18

        # Mock bs_vega to return zero for one of the strikes
        mocker.patch('src.vvm.main.bs_vega', side_effect=[0, 1, 1, 1])

        # Act & Assert
        with pytest.raises(ValueError, match="One of the computed vegas is zero; check inputs."):
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)

    # Handle cases where K1=K2=K3 (identical strikes)
    def test_identical_strikes(self, mocker):
        # Arrange
        S = 100.0
        K = 100.0
        K1 = 100.0
        K2 = 100.0
        K3 = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        sigma1 = 0.2
        sigma2 = 0.2
        sigma3 = 0.2

        # Mock bs_vega to avoid division by zero and control the output
        mocker.patch('src.vvm.main.bs_vega', return_value=1.0)

        # Act & Assert
        with pytest.raises(ValueError, match="One of the computed vegas is zero; check inputs."):
            compute_weights(K, K1, K2, K3, sigma, sigma1, sigma2, sigma3, S, T, r)