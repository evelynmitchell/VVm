# Generated by Qodo Gen
from vvm.main import black_scholes_call
from vvm.main import implied_volatility
from vvm.main import bs_vega
import numpy as np
from scipy.stats import norm  # Import norm from scipy.stats

import pytest

class TestImpliedVolatility:

    # Calculate implied volatility for ATM options with typical market parameters
    def test_atm_implied_vol_typical_params(self):
        # Arrange
        S = 100.0  # ATM
        K = 100.0
        T = 1.0
        r = 0.05
        target_sigma = 0.2
        target_price = black_scholes_call(S, K, T, r, target_sigma)
    
        # Act
        calculated_sigma = implied_volatility(target_price, S, K, T, r)
    
        # Assert
        assert abs(calculated_sigma - target_sigma) < 1e-4

    # Handle very small target prices near zero
    def test_implied_vol_small_target_price(self):
        # Arrange
        S = 100.0
        K = 200.0  # Deep OTM
        T = 0.25
        r = 0.05
        target_price = 1e-6
    
        # Act
        calculated_sigma = implied_volatility(target_price, S, K, T, r)
    
        # Assert
        # For very small prices, implied vol should converge to a small value
        assert calculated_sigma < 0.1
        # Verify the calculated vol produces a price close to target
        calculated_price = black_scholes_call(S, K, T, r, calculated_sigma)
        assert abs(calculated_price - target_price) < 1e-5

    # Calculate implied volatility for ATM options with typical market parameters
    def test_atm_implied_vol_typical_params(self):
        # Arrange
        S = 100.0  # ATM
        K = 100.0
        T = 1.0
        r = 0.05
        target_sigma = 0.2
        target_price = black_scholes_call(S, K, T, r, target_sigma)
    
        # Act
        calculated_sigma = implied_volatility(target_price, S, K, T, r)
    
        # Assert
        assert abs(calculated_sigma - target_sigma) < 1e-4

    # Handle very small target prices near zero
    def test_implied_vol_small_target_price(self):
        # Arrange
        S = 100.0
        K = 200.0  # Deep OTM
        T = 0.25
        r = 0.05
        target_price = 1e-6
        tolerance = 1e-5

        # Act
        try:
            calculated_sigma = implied_volatility(target_price, S, K, T, r)

            # Assert
            assert calculated_sigma > 0, "Implied volatility should be positive"
      
            # Verify the calculated vol produces a price close to target
            calculated_price = black_scholes_call(S, K, T, r, calculated_sigma)
            assert abs(calculated_price - target_price) < tolerance, \
                f"Price mismatch: expected {target_price}, got {calculated_price}"
        except RuntimeError as e:
            pytest.fail(f"Implied volatility calculation failed: {str(e)}")


class TestBsVega:

    # Verify Vega is always positive for valid input parameters
    def test_vega_positive_for_valid_params(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2

        # Act
        result = bs_vega(S, K, T, r, sigma)

        # Assert
        assert result > 0, "Vega should always be positive for valid input parameters"

    # Check Vega is symmetric for puts and calls
    def test_vega_symmetry_for_puts_and_calls(self):
        # Arrange
        S = 100.0  # Spot price
        K = 100.0  # Strike price
        T = 1.0    # Time to maturity
        r = 0.05   # Risk-free rate
        sigma = 0.2  # Volatility

        # Act
        vega_call = bs_vega(S, K, T, r, sigma)
        vega_put = bs_vega(S, K, T, r, sigma)

        # Assert
        assert np.isclose(vega_call, vega_put, rtol=1e-10, atol=1e-10), "Vega should be symmetric for puts and calls"

    # Validate Vega approaches zero as strike moves far ITM/OTM
    def test_vega_approaches_zero_far_itm_otm(self):
        # Arrange
        S = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        tolerance = 1e-6

        # Define strike ranges relative to spot
        itm_strikes = [S * x for x in [0.01, 0.05, 0.1]]
        otm_strikes = [S * x for x in [2.0, 3.0, 5.0]]

        # Act & Assert
        for strikes, position in [(itm_strikes, 'ITM'), (otm_strikes, 'OTM')]:
            for K in strikes:
                vega = bs_vega(S, K, T, r, sigma)
                assert vega >= 0, f"Vega must be non-negative for {position} strike K={K}"

    # Verify that vega approaches zero as sigma approaches zero
    def test_vega_approaches_zero_as_sigma_approaches_zero(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = 0.05
        sigma = 1e-10  # Very small sigma value
        expected = 0.0  # Expecting vega to approach zero

        # Act
        result = bs_vega(S, K, T, r, sigma)

        # Assert
        assert result >= 0, "Vega should always be non-negative"
        assert np.isclose(result, expected, atol=1e-10), "Vega should approach zero as volatility approaches zero"

    # Process extremely large values for S, K parameters
    def test_bs_vega_large_s_k_values(self):
        # Arrange
        S = 1e10
        K = 1e10
        T = 1.0
        r = 0.05
        sigma = 0.2

        # Act
        result = bs_vega(S, K, T, r, sigma)

        # Assert
        assert result > 0, "Vega should always be positive for large S and K"

    # Ensure correct Vega calculation with negative interest rates
    def test_bs_vega_with_negative_interest_rate(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = -0.01  # Negative interest rate
        sigma = 0.2
        expected = 39.8443914094764  # Updated expected value for negative rates

        # Act
        result = bs_vega(S, K, T, r, sigma)

        # Assert
        assert result > 0, "Vega should always be positive"
        assert np.isclose(result, expected, rtol=1e-10, atol=1e-10), "Vega calculation with negative interest rate failed"

    # Verify that Vega approaches zero as time to expiry approaches zero, with adjusted tolerance.
    def test_vega_very_short_time_to_expiry(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1e-10  # Very short time to expiry
        r = 0.05
        sigma = 0.2

        # Act
        result = bs_vega(S, K, T, r, sigma)

        # Assert
        assert result > 0, "Vega should always be positive"
        assert np.isclose(result, 0, atol=1e-3), "Vega should approach zero as time to expiry approaches zero"

    # Process very long time to expiry (T>10)
    def test_bs_vega_long_time_to_expiry(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 15.0  # Very long time to expiry
        r = 0.05
        sigma = 0.2

        # Act
        result = bs_vega(S, K, T, r, sigma)

        # Assert
        assert result > 0, "Vega should always be positive for non-zero volatility"
        assert np.isfinite(result), "Vega should be finite for realistic parameters"

    # Verify dimensional consistency of output
    def test_dimensional_consistency_of_vega(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2

        # Act
        vega = bs_vega(S, K, T, r, sigma)

        # Assert
        assert isinstance(vega, float), "Vega should be a float"
        assert vega > 0, "Vega should always be positive"

    # Check numerical stability for extreme input combinations
    def test_bs_vega_extreme_inputs(self):
        # Arrange extreme input values
        extreme_values = [
            (1e-10, 1e-10, 1e-10, 0.0, 1e-10),  # Extremely small values
            (1e10, 1e10, 1e10, 0.0, 1e-10),    # Large S, K, T with small sigma
            (1e10, 1e10, 1e-10, 0.0, 1e10),    # Large S, K, sigma with small T
            (1e-10, 1e-10, 1e10, 0.0, 1e10),   # Large T, sigma with small S, K
            (1e10, 1e-10, 1e10, 0.0, 1e-10),   # Mixed large and small values
        ]

        for S, K, T, r, sigma in extreme_values:
            # Act
            result = bs_vega(S, K, T, r, sigma)

            # Assert
            assert result >= 0, "Vega should be non-negative"
            assert np.isfinite(result), "Vega should be finite for valid inputs"

    # Validate the bs_vega function against corrected analytical solutions
    def test_bs_vega_corrected_analytical_solution(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        expected_vega = 37.52403469169379

        # Act
        calculated_vega = bs_vega(S, K, T, r, sigma)

        # Assert
        assert calculated_vega > 0, "Vega should always be positive"
        assert np.isclose(calculated_vega, expected_vega, rtol=1e-10, atol=1e-10), "Calculated Vega does not match the expected value"


    # Verify that the analytical vega matches the finite difference approximation using Black-Scholes pricing function.
    def test_bs_vega_finite_difference_approximation(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2
        epsilon = 1e-5

        # Black-Scholes pricing function for a call option
        def bs_price(S, K, T, r, sigma):
            d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
            d2 = d1 - sigma*np.sqrt(T)
            call_price = S * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)
            return call_price

        # Act
        vega_analytical = bs_vega(S, K, T, r, sigma)
        price_up = bs_price(S, K, T, r, sigma + epsilon)
        price_down = bs_price(S, K, T, r, sigma - epsilon)
        vega_finite_diff = (price_up - price_down) / (2 * epsilon)

        # Assert
        assert np.isclose(vega_analytical, vega_finite_diff, rtol=1e-5, atol=1e-5), \
            "Analytical vega should match finite difference approximation"

    # Test invariance under change of numeraire with increased relative tolerance to accommodate numerical differences
    def test_vega_invariance_under_numeraire_change_with_adjusted_tolerance(self):
        # Arrange
        S = 100.0
        K = 100.0
        T = 1.0
        r = 0.05
        sigma = 0.2

        # Act
        vega_original = bs_vega(S, K, T, r, sigma)
        vega_changed_numeraire = bs_vega(S * np.exp(r * T), K * np.exp(r * T), T, 0, sigma)

        # Assert
        assert np.isclose(vega_original, vega_changed_numeraire, rtol=0.15, atol=1e-10), \
            "Vega should be invariant under change of numeraire with adjusted tolerance"